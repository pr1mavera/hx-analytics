---
title: 实现细节
---

## 模式切换机制

+ sdk初始化之后，会根据当前环境（是否在埋点配置用iframe内）进入对应模式
+ 可在 `HXAnalytics` 类直接通过 `this.mode = 'report';` 的方式切换模式，
+ 每个模式都有自己的基本生命周期（onEnter、onExit），会在模式切换的时候自动触发（通过重写 `this.mode` 的 `get / set`）

## 埋点命中规则

sdk在客户端记录的是全量行为日志，势必存在业务人员不关心的无效数据，需要在入库前根据埋点配置信息进行数据清洗操作

客户行为数据（type: 2 且 isSysEvt: N）需要在清洗阶段会根据以下字段进行过滤：
+ sysId - 系统唯一标识
+ pageId - 页面唯一标识
+ funcId - 埋点唯一标识

#### sysId
接入sdk时每个提供获取的唯一标识

#### pageId
通过 `window.location.pathname` 和 `window.location.hash` 除去 `query` 拼接得到
``` js
_.getPagePath = () => {
    const { pathname, hash } = window.location;
    return pathname + _.first(hash.split('?'));
};
```

#### funcId
根据 [whats-element](https://github.com/rowthan/whats-element) 生成页面元素唯一标识，同时拼接上 sysId 、 pageId  
在配置阶段及上报阶段统一使用该规则命中埋点，大致组成如下
``` js
_.getElemPid = function (sysId, pageId, e) {
    try {
        const { type, wid } = new whatsElement().getUniqueId(e);
        /**
         * wid: 元素指纹
         * type: 根据指纹可以唯一获取到元素的API
         * sysId: sysId
         * pageId: pageId
         * 
         * 统一使用 '!' 连接
         */
        return `${wid}!${type}!${sysId}!${pageId}`;
    } catch {
        return null;
    }
};
```

## 数据报的组装及中间件机制

## 数据上报缓冲及边界处理

## 精确停留时长记录

记录客户在某个页面精确的停留时长，需要在合适时机记录 **活跃节点** 与 **非活跃节点**
+ 活跃事件
    + 页面加载
    + 页面切换
    + 页面从后台切换至前台
+ 非活跃事件
    + 页面卸载
    + 页面从前台切换至后台

而且还需同时处理多页和单页的页面跳转

#### 思路

`PageTracer` 组件为页面活跃节点提供 **栈** 数据结构用于保存，当触发活跃事件时入栈一条 **活跃节点** ，触发非活跃事件时入栈一条 **非活跃节点** ，另外提供接口用于计算当前活跃时长
![页面活跃节点栈](/hx-analytics/img/页面活跃节点栈.jpeg)
活跃时长计算方式为栈内节点两两一组，用 **非活跃节点** 时间戳 - **活跃节点** ，再相加，即可得到总时长
![停留时长](/hx-analytics/img/停留时长.jpeg)

### 节点记录多次触发问题

#### 问题描述
正如上述的记录方案，停留时长计算要求的栈内数据是：
+ 一条 **活跃节点** 一条非 **非活跃节点**，重叠出现
+ 栈底需要是 **活跃节点**，栈顶需要是 **非活跃节点**
这是在一种较为理想的情况下的基本方案，稳定性是建立在设备触发 `visibilitychange` 事件的正确性上的，然而在移动设备恶劣的环境下，免不了出现两条 **活跃节点** 连续入栈的情况（两条 **非活跃节点** 同理）

#### 解决方案
在记录 **活跃节点** 时（**非活跃节点** 同理），做一次栈顶数据校验，判断当前栈顶是 **非活跃节点** 才入栈，否则忽略  
这样可以保证最终停留时长计算的正确性

### 单页页面跳转问题

#### 问题描述
现代单页应用基本使用 `hash` 、 `history` 的方式通过欺骗浏览器达到更改页面路由、视图，但是页面不重新刷新的目的，因此单纯的页面加载卸载等事件便不能完全监控页面的切换

#### 解决方案
单页应用插件基本通过调用 `pushState` 、`replaceState` 原生API来触发 `history` 状态的改变  
通过类似于注册 [猴子补丁](https://zh.wikipedia.org/wiki/%E7%8C%B4%E8%A1%A5%E4%B8%81) 的方式，我们可以在运行时将这些浏览器API包装起来，在单页应用插件调用这些API的时候，向宿主环境抛出（dispatchEvent）一个自定义事件来通知sdk，这样便可以和处理页面加载卸载事件一样处理这些事件

一个可用的猴子补丁工具
``` js
/**
 * 原生API派发浏览器事件猴子补丁
 * 
 * @param {any} orig 要重写的原生API
 * @param {String} orig 派发的事件名称
 */
_.nativeCodeEventPatch = (orig, type) => {
    // 修改原生事件的行为，并返回用于覆盖
    return  function() {
        // 执行原生事件，缓存结果
        let res = orig.apply(this, arguments);
        // 初始化原生事件，注意将传入的事件名称转成小写
        let e = new Event(type.toLowerCase());
        Object.assign(e, { arguments });
        // 派发自定义事件
        window.dispatchEvent(e);
        // 将原生事件执行结果返回，供单页应用插件处理
        return res;
    }
};
```

使用
``` js
window.history.pushState = this._.nativeCodeEventPatch(window.history.pushState, 'pushState');
window.history.replaceState = this._.nativeCodeEventPatch(window.history.pushState, 'replaceState');
```

实际在使用的时候，可以将 `pushstate` 、 `replacestate` 、 `popstate` 、 `hashchange` 作为一类事件统一监控起来，这样可以统一单页应用不同的路由模式（hash mode, history mode），当然需在订阅的时候做过滤处理，当前若不符合页面切换条件（当前pathId与上一个路由pathId相同）的应过滤掉

### 移动设备数据丢失问题

#### 问题描述
移动设备如果直接从后台删掉应用，将导致此次访问的停留时长数据丢失

#### 解决方案
+ 在每次应用退至后台时，<u>记录一次停留时长数据，组装标准的上报数据包，直接**缓存在本地缓存**</u>，并记录缓存的chunk
+ 若应用切至前台时，查看当前是否存在上次停留时长数据的缓存，若存在则清空
+ 若应用未切至前台（直接从后台删掉应用），则<u>本次访问停留时长为**应用刚刚切至后台时的保存在本地缓存的数据**，并且将在下次访问该页面时上报</u>
+ 注：iOS微信浏览器上 `visibilitychange` 事件存在问题，前后台切换时不会触发，因此停留时长会同时记录切至后台的时间

以这样的方式能够基本规避数据丢失问题

## 埋点高亮圈选机制

使用canvas，通过监控配置人员鼠标移动给当前鼠标停留位置上最顶层的dom设置蒙板，形成高亮效果

#### 整体流程

1. 父层推送指令至sdk，切换当前模式为埋点配置模式
2. sdk开启埋点配置模式
    + 开启canvas蒙板（DomMasker），并查询当前页面已设置过得埋点信息，作为 **预设埋点** 
    + 监控鼠标移动（mousemove）
    + 获取鼠标悬停位置最顶层的dom元素，计算宽高并与 **预设埋点** 一同绘制到canvas上
3. 当鼠标点击某个高亮的蒙板，sdk将选中埋点推送指令至父层，同时设置当前埋点配置模式静默状态（此时依然是埋点配置模式，只是不监控鼠标移动、鼠标点击，只监控父层消息推送）
4. 至此便完成了一次埋点圈选过程，父层可以通过给sdk推送重置消息重新开启流程

### 双缓存机制解决蒙板闪烁问题

#### 遇到问题
鼠标移动，需要 `clearRect` 清空画布，先重新绘制 **预设埋点** ，再绘制当前鼠标悬停位置dom高亮的区域  
但是这个过程中一旦重新绘制 **预设埋点** 的时间较长，将会存在画布闪烁问题  
比如当前一屏画面中 **预设埋点** 有十个，若在重置画布的时候循环的一个个 `fillRect` ，等待绘制的时间将很长，从而导致闪烁问题  
然而在一次圈选流程中 **预设埋点** 是不会变的，因此重新绘制不但会出现闪烁问题，而且从逻辑角度讲也不应该

#### 解决思路
将 **预设埋点** 从网络请求过来之后映射成埋点信息，首先在内存中初始化另外一个canvas，将 **预设埋点** 绘制上去作为内存缓冲，在每次鼠标移动需要重新绘制高亮区域的时候，重载内存缓冲canvas，相当于多个 **预设埋点** 只通过一次绘制图形操作即可绘制完毕，从而消除蒙板闪烁问题

